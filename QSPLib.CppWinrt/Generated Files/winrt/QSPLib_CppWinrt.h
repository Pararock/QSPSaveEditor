// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.191018.6

#ifndef WINRT_QSPLib_CppWinrt_H
#define WINRT_QSPLib_CppWinrt_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.191018.6"), "Mismatched C++/WinRT headers.");
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Windows.Storage.2.h"
#include "winrt/impl/Windows.UI.Xaml.Data.2.h"
#include "winrt/impl/QSPLib_CppWinrt.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_QSPLib_CppWinrt_IEngine<D>::LoadGameWorld(Windows::Storage::StorageFile const& questGameWorld) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::IEngine)->LoadGameWorld(*(void**)(&questGameWorld), &operation));
        return Windows::Foundation::IAsyncOperation<QSPLib_CppWinrt::Result>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_QSPLib_CppWinrt_IEngine<D>::CurrentGame() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::IEngine)->get_CurrentGame(&value));
        return Windows::Storage::StorageFile{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_QSPLib_CppWinrt_IEngine<D>::CloseGameWorld() const
    {
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::IEngine)->CloseGameWorld());
    }
    template <typename D> auto consume_QSPLib_CppWinrt_IEngine<D>::OpenSavedGame(Windows::Storage::StorageFile const& saveGame) const
    {
        void* operation{};
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::IEngine)->OpenSavedGame(*(void**)(&saveGame), &operation));
        return Windows::Foundation::IAsyncOperation<QSPLib_CppWinrt::Result>{ operation, take_ownership_from_abi };
    }
    template <typename D> auto consume_QSPLib_CppWinrt_IEngine<D>::CurrentSave() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::IEngine)->get_CurrentSave(&value));
        return Windows::Storage::StorageFile{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_QSPLib_CppWinrt_IEngine<D>::CurrentLocation() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::IEngine)->get_CurrentLocation(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_QSPLib_CppWinrt_IEngine<D>::Locations() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::IEngine)->get_Locations(&value));
        return Windows::Foundation::Collections::IObservableVector<QSPLib_CppWinrt::Location>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_QSPLib_CppWinrt_IEngineStatics<D>::Version() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::IEngineStatics)->get_Version(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_QSPLib_CppWinrt_IEngineStatics<D>::CompiledDate() const
    {
        Windows::Foundation::DateTime value;
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::IEngineStatics)->get_CompiledDate(put_abi(value)));
        return value;
    }
    template <typename D> auto consume_QSPLib_CppWinrt_ILineOfCode<D>::Text() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::ILineOfCode)->get_Text(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_QSPLib_CppWinrt_ILineOfCode<D>::LineNum() const
    {
        int32_t value;
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::ILineOfCode)->get_LineNum(&value));
        return value;
    }
    template <typename D> auto consume_QSPLib_CppWinrt_ILineOfCode<D>::IsMultiline() const
    {
        bool value;
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::ILineOfCode)->get_IsMultiline(&value));
        return value;
    }
    template <typename D> auto consume_QSPLib_CppWinrt_ILineOfCode<D>::Label() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::ILineOfCode)->get_Label(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_QSPLib_CppWinrt_ILineOfCode<D>::CachedStats() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::ILineOfCode)->get_CachedStats(&value));
        return Windows::Foundation::Collections::IVector<QSPLib_CppWinrt::CachedStat>{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_QSPLib_CppWinrt_ILocation<D>::Name() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::ILocation)->get_Name(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_QSPLib_CppWinrt_ILocation<D>::Desc() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::ILocation)->get_Desc(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> auto consume_QSPLib_CppWinrt_ILocation<D>::OnVisitLines() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(QSPLib_CppWinrt::ILocation)->get_OnVisitLines(&value));
        return Windows::Foundation::Collections::IVector<QSPLib_CppWinrt::LineOfCode>{ value, take_ownership_from_abi };
    }
    template <typename D>
    struct produce<D, QSPLib_CppWinrt::IEngine> : produce_base<D, QSPLib_CppWinrt::IEngine>
    {
        int32_t __stdcall LoadGameWorld(void* questGameWorld, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncOperation<QSPLib_CppWinrt::Result>>(this->shim().LoadGameWorld(*reinterpret_cast<Windows::Storage::StorageFile const*>(&questGameWorld)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CurrentGame(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Storage::StorageFile>(this->shim().CurrentGame());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CloseGameWorld() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().CloseGameWorld();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall OpenSavedGame(void* saveGame, void** operation) noexcept final try
        {
            clear_abi(operation);
            typename D::abi_guard guard(this->shim());
            *operation = detach_from<Windows::Foundation::IAsyncOperation<QSPLib_CppWinrt::Result>>(this->shim().OpenSavedGame(*reinterpret_cast<Windows::Storage::StorageFile const*>(&saveGame)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CurrentSave(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Storage::StorageFile>(this->shim().CurrentSave());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CurrentLocation(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().CurrentLocation());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Locations(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Foundation::Collections::IObservableVector<QSPLib_CppWinrt::Location>>(this->shim().Locations());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, QSPLib_CppWinrt::IEngineStatics> : produce_base<D, QSPLib_CppWinrt::IEngineStatics>
    {
        int32_t __stdcall get_Version(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Version());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CompiledDate(int64_t* value) noexcept final try
        {
            zero_abi<Windows::Foundation::DateTime>(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Foundation::DateTime>(this->shim().CompiledDate());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, QSPLib_CppWinrt::ILineOfCode> : produce_base<D, QSPLib_CppWinrt::ILineOfCode>
    {
        int32_t __stdcall get_Text(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Text());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LineNum(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<int32_t>(this->shim().LineNum());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_IsMultiline(bool* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<bool>(this->shim().IsMultiline());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Label(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Label());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_CachedStats(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Foundation::Collections::IVector<QSPLib_CppWinrt::CachedStat>>(this->shim().CachedStats());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, QSPLib_CppWinrt::ILocation> : produce_base<D, QSPLib_CppWinrt::ILocation>
    {
        int32_t __stdcall get_Name(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Name());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Desc(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Desc());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_OnVisitLines(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<Windows::Foundation::Collections::IVector<QSPLib_CppWinrt::LineOfCode>>(this->shim().OnVisitLines());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
}
WINRT_EXPORT namespace winrt::QSPLib_CppWinrt
{
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::QSPLib_CppWinrt::IEngine> : winrt::impl::hash_base {};
    template<> struct hash<winrt::QSPLib_CppWinrt::IEngineStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::QSPLib_CppWinrt::ILineOfCode> : winrt::impl::hash_base {};
    template<> struct hash<winrt::QSPLib_CppWinrt::ILocation> : winrt::impl::hash_base {};
    template<> struct hash<winrt::QSPLib_CppWinrt::Engine> : winrt::impl::hash_base {};
    template<> struct hash<winrt::QSPLib_CppWinrt::LineOfCode> : winrt::impl::hash_base {};
    template<> struct hash<winrt::QSPLib_CppWinrt::Location> : winrt::impl::hash_base {};
#endif
}
#endif
